<h1 align="center"> Openfort EIP-7702 Smart Accounts </h1>

<p align="center">
  <img src="../docs/Logo_black_primary_no_bg.png" alt="Openfort" style="width: 300px;" />
</p>

> üöß **Work In Progress**
> 
> This repository is under active development.  
> Contracts are **unaudited**, and the codebase may have **breaking changes** without notice.

**All-in-one EIP-7702 powered smart accounts with session key support**

---

## Overview

Smart wallets have made great strides in improving user experience, but still face challenges with key management, account recovery, and cross-application session management. Openfort's EIP-7702 implementations aim to solve these problems with a comprehensive smart account solution that puts users in control.

We believe smart accounts should provide an excellent experience throughout a user's journey:

- **Effortless Onboarding**: Use WebAuthn and Passkeys with no deployment transaction required  
- **Flexible Authentication**: Multiple authentication methods including EOA and WebAuthn/Passkeys  
- **Fine-grained Access Control**: Session keys with customizable permissions and spending limits  
- **Secure Transactions**: Built-in security features including whitelisting, function filtering, and time-based controls  
- **Seamless Experience**: Full compatibility with ERC-4337 account abstraction standard  
- **Gas Sponsorship**: Allow applications to pay for user transactions through session keys  
- **No Vendor Lock-in**: Built on EIP-7702 and ERC-4337 standards for maximum interoperability  
- **üü¢ Live Demo**: [https://7702.openfort.xyz](https://7702.openfort.xyz)

---
<br></br>
## EIP7702 Quickstart
[EIP-7702](https://eips.ethereum.org/EIPS/eip-7702) is a upgrade (Pectra) Ethereum enhancement behaving both as a smart account and as a regular EOA, effectively creating a ‚Äúhybrid‚Äù account enabling embedding EVM code into an Externally Owned Account (EOA). Our [video blog series](https://www.youtube.com/watch?v=94VhTY-1ZsI) has more details for all of you.
Account Abstraction has many features EOA holders can now access due to this. Account Abstraction offers sponsored gas fees as well as multiple operations batched in only one transaction plus session keys in addition to chain abstraction support with similar conveniences.

This guide walks through a basic demo that leverages ERC-4337 along with EIP-7702 so an EOA can directly send a gasless user operation. This [video blog](https://www.youtube.com/watch?v=bE7YUrThS5k) gives info regarding the architecture of openfort 7702 account.

---
<br></br>
## Installation
```bash
npm install viem @noble/secp256k1 ox permissionless
```
```bash
yarn add viem @noble/secp256k1 ox permissionless
```

---

## Steps
<kbd style="padding: 2px 6px; font-size: 18px; background-color: #fc3c2f; border: 1px solid #ccc; border-radius: 4px;">1</kbd>&nbsp;&nbsp;&nbsp;&nbsp;*Prepares an EIP-7702 Authorization for signing. This Action will fill the required fields of the Authorization object if they are not provided (e.g. nonce and chainId).*
<br></br> ****Contract****: [0x211DC8EB0b09F5b762979C8681641dB05D7cd481](https://sepolia.etherscan.io/address/0x211dc8eb0b09f5b762979c8681641db05d7cd481)

#### `Self-execution`
```ts

import { sepolia } from 'viem/chains';
import { privateKeyToAccount } from 'viem/accounts'

const SEPOLIA_RPC = '';

const walletClient = createWalletClient({
  account,
  chain: sepolia,
  transport: http(SEPOLIA_RPC),
});

const authorization = await walletClient.prepareAuthorization({
  account: privateKeyToAccount('0x...'),
  contractAddress: '0x211DC8EB0b09F5b762979C8681641dB05D7cd481',
  executor: 'self', 
});
```
* Type: 'self' | undefined
* Source: [VIEM](https://viem.sh/docs/eip7702/prepareAuthorization)

#### `Ephemeral EOA`

```ts
import { createClient } from "viem";
import { sepolia } from 'viem/chains';
import { prepareAuthorization } from "viem/actions";
import { generatePrivateKey, privateKeyToAccount, signAuthorization } from "viem/accounts";

const privateKey = generatePrivateKey();
const signer = privateKeyToAccount(privateKey);

const client = createClient({
  sepolia,
  pollingInterval: 1_000,
  transport: http()
});

const authorization = await prepareAuthorization(client, {
  account: signer.address,
  contractAddress: '0x211DC8EB0b09F5b762979C8681641dB05D7cd481'
});
```

<kbd style="padding: 2px 6px; font-size: 18px; background-color: #fc3c2f; border: 1px solid #ccc; border-radius: 4px;">2</kbd>&nbsp;&nbsp;&nbsp;&nbsp;*Initialize the account with a WebAuthn owner and guardian.*
```ts
function initialize(
    Key calldata _key,
    KeyReg calldata _keyData,
    bytes memory _signature,
    bytes32 _initialGuardian
) external initializer {}
```

#### `Create WebAuthn Key`
```ts
import { toHex } from "viem";
import { Bytes, WebAuthnP256 } from "ox";

// Create a WebAuthn credential using the account address as the user ID
const credential = await WebAuthnP256.createCredential({
  authenticatorSelection: {
    requireResidentKey: false,
    residentKey: "preferred",        // Store credential on device when possible
    userVerification: "required",    // Require biometric/PIN verification
  },
  user: {
    id: Bytes.from(account.address),
    name: `${account.address.slice(0, 6)}...${account.address.slice(-4)}`,
  },
});

// Store the credential ID for future authentication
const credentialId = credential.id;

const x = toHex(credential.publicKey.x, { size: 32 });
const y = toHex(credential.publicKey.y, { size: 32 });
```

#### `CallData`
* Prepate Key Data
```ts
import { zeroAddress, toHex, keccak256, encodeFunctionData } from "viem";

export enum KeyType {
  EOA = 0,
  WEBAUTHN = 1,
  P256 = 2,
  P256_NON_EXTRACTABLE = 3,
}

const key = {                               
  pubKey: {                         
    x: toHex(x),                   
    y: toHex(y),                   
  },
  eoaAddress: zeroAddress,         
  keyType: KeyType.WEBAUTHN,       
} as const;
```
<br></br> * Prepate Token Spend  
```ts
const spendTokenInfo = {
  token: zeroAddress,             
  limit: 0n,
} as const;
```
<br></br> * Prepate Key Registretion Data 
```ts
const keyReg = {
  validUntil: 0n,
  validAfter: 0n,
  limit: 0n,
  whitelisting: false,
  contractAddress: zeroAddress,
  spendTokenInfo: spendTokenInfo,
  allowedSelectors: ['0xdeedbeff'],
  ethLimit: 0n
} as const;

const initialGuardian = keccak256('address');
```
<br></br> * Call Data (If Sponsored use with `userOperation`) 
```ts

// Prepare the initialization call data
const callData = encodeFunctionData({
  abi: accountABI,
  functionName: "initialize",
  args: [
    key,
    keyReg,                    
    SIGNATURE_EIP712,  // sign with EOA/EPHEMERAL EOA `function getDigestToInit`
    initialGuardian
  ]
});

// Create the user operation with EIP-7702 authorization if EPHEMERAL EOA
const userOperation = await walletClient.prepareUserOperation({
  callData,
  authorization: signedAuthorization,  // EIP-7702 authorization signature
});
```
---

<kbd style="padding: 2px 6px; font-size: 18px; background-color: #fc3c2f; border: 1px solid #ccc; border-radius: 4px;">3</kbd>&nbsp;&nbsp;&nbsp;&nbsp;*Register Session Key P256.*
```js
function registerKey(Key calldata _key, KeyReg calldata _keyData) public {}
```
#### `Creating a Session Key`

* Session keys are also non-extractable P256 keys, but they're created using the WebCrypto API and stored locally:

```ts
import { WebCryptoP256 } from "ox";

// Generate a new P256 key pair for the session
const keyPair = await WebCryptoP256.createKeyPair();
const publicKey = await WebCryptoP256.getPublicKey({ 
  publicKey: keyPair.publicKey 
});

// Store the key pair securely (e.g., in IndexedDB)
await storeSessionKey(keyPair);
```

#### `Registering the Session Key`
The session key must be registered with the smart account, defining its permissions and validity:
* Prepate Key Data
```ts
const key = {                               
  pubKey: {                         
    x: toHex(publicKey.x),         // The P256 public key x coordinate
    y: toHex(publicKey.y),         // The P256 public key y coordinate           
  },
  eoaAddress: zeroAddress,         
  keyType: KeyType.P256_NON_EXTRACTABLE,       
} as const;
```ts
const spendTokenInfo = {
  token: TOKEN_ADDRESS,             
  limit: SPEND_LIMIT,
} as const;
```
<br></br>* Prepate Key Registretion Data 
```ts
const keyReg = {
  validUntil: VALID_UNTIL,
  validAfter: VALID_AFTER,
  limit: ACTIONS_LIMIT,
  whitelisting: true,
  contractAddress: CONTRACT_ADDRESS,
  spendTokenInfo: spendTokenInfo,
  allowedSelectors: [ALLOW_SELECTORS],
  ethLimit: ETH_SPEND_LIMIT
} as const;
```
<br></br>* Call Data (If Sponsored use with `userOperation`) 
```ts
const callData = encodeFunctionData({
  abi: accountABI,
  functionName: 'registerSessionKey',
  args: [
    key,
    keyReg
  ]
});

// This registration requires WebAuthn approval
const userOperation = await walletClient.prepareUserOperation({
  callData,
  signature: webAuthnStubSignature,
});

// Sign with WebAuthn (one-time approval for session key)
const webauthnData = await WebAuthnP256.sign({
  challenge: getUserOperationHash(userOperation),
  credentialId,
  rpId: window.location.hostname,
  userVerification: "required",
});
```
