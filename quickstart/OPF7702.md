<h1 align="center"> Openfort EIP-7702 Smart Accounts </h1>

<p align="center">
  <img src="../docs/Logo_black_primary_no_bg.png" alt="Openfort" style="width: 300px;" />
</p>

> üöß **Work In Progress**
> 
> This repository is under active development.  
> Contracts are **unaudited**, and the codebase may have **breaking changes** without notice.

**All-in-one EIP-7702 powered smart accounts with session key support**

---

## Overview

Smart wallets have made great strides in improving user experience, but still face challenges with key management, account recovery, and cross-application session management. Openfort's EIP-7702 implementations aim to solve these problems with a comprehensive smart account solution that puts users in control.

We believe smart accounts should provide an excellent experience throughout a user's journey:

- **Effortless Onboarding**: Use WebAuthn and Passkeys with no deployment transaction required  
- **Flexible Authentication**: Multiple authentication methods including EOA and WebAuthn/Passkeys  
- **Fine-grained Access Control**: Session keys with customizable permissions and spending limits  
- **Secure Transactions**: Built-in security features including whitelisting, function filtering, and time-based controls  
- **Seamless Experience**: Full compatibility with ERC-4337 account abstraction standard  
- **Gas Sponsorship**: Allow applications to pay for user transactions through session keys  
- **No Vendor Lock-in**: Built on EIP-7702 and ERC-4337 standards for maximum interoperability  
- **üü¢ Live Demo**: [https://7702.openfort.xyz](https://7702.openfort.xyz)

---
<br></br>
## EIP7702 Quickstart
[EIP-7702](https://eips.ethereum.org/EIPS/eip-7702) is a upgrade (Pectra) Ethereum enhancement behaving both as a smart account and as a regular EOA, effectively creating a ‚Äúhybrid‚Äù account enabling embedding EVM code into an Externally Owned Account (EOA). Our [video blog series](https://www.youtube.com/watch?v=94VhTY-1ZsI) has more details for all of you.
Account Abstraction has many features EOA holders can now access due to this. Account Abstraction offers sponsored gas fees as well as multiple operations batched in only one transaction plus session keys in addition to chain abstraction support with similar conveniences.

This guide walks through a basic demo that leverages ERC-4337 along with EIP-7702 so an EOA can directly send a gasless user operation. This [video blog](https://www.youtube.com/watch?v=bE7YUrThS5k) gives info regarding the architecture of openfort 7702 account.

---
<br></br>
## Installation
```bash
npm install viem @noble/secp256k1 ox permissionless
```
```bash
yarn add viem @noble/secp256k1 ox permissionless
```

---

## Steps
<kbd style="padding: 2px 6px; font-size: 12px; background-color: #eee; border: 1px solid #ccc; border-radius: 4px;">1</kbd> *Prepares an EIP-7702 Authorization for signing. This Action will fill the required fields of the Authorization object if they are not provided (e.g. nonce and chainId).*
#### `Self-execution`
Contract: [0x211DC8EB0b09F5b762979C8681641dB05D7cd481](https://sepolia.etherscan.io/address/0x211dc8eb0b09f5b762979c8681641db05d7cd481)
```ts

import { sepolia } from 'viem/chains';
import { privateKeyToAccount } from 'viem/accounts'

const SEPOLIA_RPC = '';

const walletClient = createWalletClient({
  account,
  chain: sepolia,
  transport: http(SEPOLIA_RPC),
});

const authorization = await walletClient.prepareAuthorization({
  account: privateKeyToAccount('0x...'),
  contractAddress: '0x211DC8EB0b09F5b762979C8681641dB05D7cd481',
  executor: 'self', 
});
```
* Type: 'self' | undefined
* Source: [VIEM](https://viem.sh/docs/eip7702/prepareAuthorization)

#### `Ephemeral EOA`

```ts
import { createClient } from "viem";
import { sepolia } from 'viem/chains';
import { prepareAuthorization } from "viem/actions";
import { generatePrivateKey, privateKeyToAccount, signAuthorization } from "viem/accounts";

const privateKey = generatePrivateKey();
const signer = privateKeyToAccount(privateKey);

const client = createClient({
  sepolia,
  pollingInterval: 1_000,
  transport: http()
});

const authorization = await prepareAuthorization(client, {
  account: signer.address,
  contractAddress: '0x211DC8EB0b09F5b762979C8681641dB05D7cd481'
});
```