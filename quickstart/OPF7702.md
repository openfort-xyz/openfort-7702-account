<h1 align="center"> Openfort EIP-7702 Smart Accounts </h1>

<p align="center">
  <img src="../docs/Logo_black_primary_no_bg.png" alt="Openfort" style="width: 300px;" />
</p>

> üöß **Work In Progress**
> 
> This repository is under active development.  
> Contracts are **unaudited**, and the codebase may have **breaking changes** without notice.

**All-in-one EIP-7702 powered smart accounts with session key support**

---

## Overview

Smart wallets have made great strides in improving user experience, but still face challenges with key management, account recovery, and cross-application session management. Openfort's EIP-7702 implementations aim to solve these problems with a comprehensive smart account solution that puts users in control.

We believe smart accounts should provide an excellent experience throughout a user's journey:

- **Effortless Onboarding**: Use WebAuthn and Passkeys with no deployment transaction required  
- **Flexible Authentication**: Multiple authentication methods including EOA and WebAuthn/Passkeys  
- **Fine-grained Access Control**: Session keys with customizable permissions and spending limits  
- **Secure Transactions**: Built-in security features including whitelisting, function filtering, and time-based controls  
- **Seamless Experience**: Full compatibility with ERC-4337 account abstraction standard  
- **Gas Sponsorship**: Allow applications to pay for user transactions through session keys  
- **No Vendor Lock-in**: Built on EIP-7702 and ERC-4337 standards for maximum interoperability  
- **üü¢ Live Demo**: [https://7702.openfort.xyz](https://7702.openfort.xyz)

---
<br></br>
## EIP7702 Quickstart
[EIP-7702](https://eips.ethereum.org/EIPS/eip-7702) is a upgrade (Pectra) Ethereum enhancement behaving both as a smart account and as a regular EOA, effectively creating a ‚Äúhybrid‚Äù account enabling embedding EVM code into an Externally Owned Account (EOA). Our [video blog series](https://www.youtube.com/watch?v=94VhTY-1ZsI) has more details for all of you.
Account Abstraction has many features EOA holders can now access due to this. Account Abstraction offers sponsored gas fees as well as multiple operations batched in only one transaction plus session keys in addition to chain abstraction support with similar conveniences.

This guide walks through a basic demo that leverages ERC-4337 along with EIP-7702 so an EOA can directly send a gasless user operation. This [video blog](https://www.youtube.com/watch?v=bE7YUrThS5k) gives info regarding the architecture of openfort 7702 account.

We'll demonstrate how to build a complete smart account system that:

- Creates secure passkeys using WebAuthn
- Initializes smart accounts with non-extractable keys
- Signs and executes UserOperations seamlessly
- Implements session keys for enhanced user experience
---
<br></br>
## Installation
```bash
npm install viem @noble/secp256k1 ox permissionless
```
```bash
yarn add viem @noble/secp256k1 ox permissionless
```

---
## Why WebAuthn + P256 for Smart Accounts?
Customary wallets leave private keys open to the application layer since they form many attack vectors. Fundamentally, WebAuthn changes this via keeping private keys where extraction is impossible in secure hardware (like your device's secure enclave or a hardware security key).

This approach delivers when it is combined along with EIP-4337 and EIP-7702 abstraction standards.

- Private keys never leave from the secure hardware. Security is therefore able to be maintained.
- For superior UX no seed phrases are needed. Superior UX also means there is no key management for the users.
- Biometrics grant authentication across many device types.
- Future-Proof: Web standards that are widely adopted are leveraged.

---
## Steps
<kbd style="padding: 2px 6px; font-size: 18px; background-color: #fc3c2f; border: 1px solid #ccc; border-radius: 4px;">1</kbd>&nbsp;&nbsp;&nbsp;&nbsp;*Prepares an EIP-7702 Authorization for signing. This Action will fill the required fields of the Authorization object if they are not provided (e.g. nonce and chainId).*
<br></br> ****Contract****: [0x211DC8EB0b09F5b762979C8681641dB05D7cd481](https://sepolia.etherscan.io/address/0x211dc8eb0b09f5b762979c8681641db05d7cd481)

#### `Self-execution`
```ts

import { sepolia } from 'viem/chains';
import { privateKeyToAccount } from 'viem/accounts'

const SEPOLIA_RPC = '';

const walletClient = createWalletClient({
  account,
  chain: sepolia,
  transport: http(SEPOLIA_RPC),
});

const authorization = await walletClient.prepareAuthorization({
  account: privateKeyToAccount('0x...'),
  contractAddress: '0x211DC8EB0b09F5b762979C8681641dB05D7cd481',
  executor: 'self', 
});
```
* Type: 'self' | undefined
* Source: [VIEM](https://viem.sh/docs/eip7702/prepareAuthorization)

#### `Ephemeral EOA`

```ts
import { createClient } from "viem";
import { sepolia } from 'viem/chains';
import { prepareAuthorization } from "viem/actions";
import { generatePrivateKey, privateKeyToAccount, signAuthorization } from "viem/accounts";

const privateKey = generatePrivateKey();
const signer = privateKeyToAccount(privateKey);

const client = createClient({
  sepolia,
  pollingInterval: 1_000,
  transport: http()
});

const authorization = await prepareAuthorization(client, {
  account: signer.address,
  contractAddress: '0x211DC8EB0b09F5b762979C8681641dB05D7cd481'
});
```
---
<br></br> 
---
<kbd style="padding: 2px 6px; font-size: 18px; background-color: #fc3c2f; border: 1px solid #ccc; border-radius: 4px;">2</kbd>&nbsp;&nbsp;&nbsp;&nbsp;*Initialize the account with a WebAuthn owner and guardian.*
```ts
function initialize(
    Key calldata _key,
    KeyReg calldata _keyData,
    bytes memory _signature,
    bytes32 _initialGuardian
) external initializer {}
```

#### `Creating Your First Passkey`
The adventure begins with creating a WebAuthn credential that will serve for your smart account as the primary authentication method. Your device ties to this credential as well as biometric authentication and a PIN protects that same device.
```ts
import { toHex } from "viem";
import { Bytes, WebAuthnP256 } from "ox";

// Create a WebAuthn credential using the account address as the user ID
const credential = await WebAuthnP256.createCredential({
  authenticatorSelection: {
    requireResidentKey: false,
    residentKey: "preferred",        // Store credential on device when possible
    userVerification: "required",    // Require biometric/PIN verification
  },
  user: {
    id: Bytes.from(account.address),
    name: `${account.address.slice(0, 6)}...${account.address.slice(-4)}`,
  },
});

// Store the credential ID for future authentication
const credentialId = credential.id;

const x = toHex(credential.publicKey.x, { size: 32 });
const y = toHex(credential.publicKey.y, { size: 32 });
```
* A unique key pair that is bound to their device is then created when this process prompts authentication by the user through Face ID, Touch ID, Windows Hello, etc. The private key remains within secure hardware. Smart account initialization returns back the public key.

#### `CallData`
With the WebAuthn credential now created, a smart account recognizing this passkey as its primary signer can be initialized:
* Prepate Key Data
```ts
import { zeroAddress, toHex, keccak256, encodeFunctionData } from "viem";

export enum KeyType {
  EOA = 0,
  WEBAUTHN = 1,
  P256 = 2,
  P256_NON_EXTRACTABLE = 3,
}

const key = {                               
  pubKey: {                         
    x: toHex(x),                   
    y: toHex(y),                   
  },
  eoaAddress: zeroAddress,         
  keyType: KeyType.WEBAUTHN,       
} as const;
```

<br></br> 
* Prepate Token Spend  
```ts
const spendTokenInfo = {
  token: zeroAddress,             
  limit: 0n,
} as const;
```

<br></br> 
* Prepate Key Registretion Data 
```ts
const keyReg = {
  validUntil: 0n,
  validAfter: 0n,
  limit: 0n,
  whitelisting: false,
  contractAddress: zeroAddress,
  spendTokenInfo: spendTokenInfo,
  allowedSelectors: ['0xdeedbeff'],
  ethLimit: 0n
} as const;

const initialGuardian = keccak256('address');
```
<br></br> 
* Call Data (If Sponsored use with `userOperation`) 
```ts

// Prepare the initialization call data
const callData = encodeFunctionData({
  abi: accountABI,
  functionName: "initialize",
  args: [
    key,
    keyReg,                    
    SIGNATURE_EIP712,  // sign with EOA/EPHEMERAL EOA `function getDigestToInit`
    initialGuardian
  ]
});

// Create the user operation with EIP-7702 authorization if EPHEMERAL EOA
const userOperation = await walletClient.prepareUserOperation({
  callData,
  authorization: signedAuthorization,  // EIP-7702 authorization signature
});
```
* An EOA can temporarily act as a smart contract because EIP-7702 authorization exists so it enables the initialization process. After execution of this UserOperation, your smart account is ready for WebAuthn-based transactions.
---
<br></br> 
---
<kbd style="padding: 2px 6px; font-size: 18px; background-color: #fc3c2f; border: 1px solid #ccc; border-radius: 4px;">3</kbd>&nbsp;&nbsp;&nbsp;&nbsp;*Register Session Key P256.*
```js
function registerKey(Key calldata _key, KeyReg calldata _keyData) public {}
```

#### `Creating a Session Key`

* Session keys are additionally non-extractable P256 keys that exist. They are created through usage of the WebCrypto API and are stored in a local way:

```ts
import { WebCryptoP256 } from "ox";

// Generate a new P256 key pair for the session
const keyPair = await WebCryptoP256.createKeyPair();
const publicKey = await WebCryptoP256.getPublicKey({ 
  publicKey: keyPair.publicKey 
});

// Store the key pair securely (e.g., in IndexedDB)
await storeSessionKey(keyPair);
```

#### `Registering the Session Key`
The session key must be registered with the smart account because it defines its permissions along with validity:
* Prepate Key Data
```ts
const key = {                               
  pubKey: {                         
    x: toHex(publicKey.x),         // The P256 public key x coordinate
    y: toHex(publicKey.y),         // The P256 public key y coordinate           
  },
  eoaAddress: zeroAddress,         
  keyType: KeyType.P256_NON_EXTRACTABLE,       
} as const;

const spendTokenInfo = {
  token: TOKEN_ADDRESS,             
  limit: SPEND_LIMIT,
} as const;
```

<br></br>
* Prepate Key Registretion Data 
```ts
const keyReg = {
  validUntil: VALID_UNTIL,
  validAfter: VALID_AFTER,
  limit: ACTIONS_LIMIT,
  whitelisting: true,
  contractAddress: CONTRACT_ADDRESS,
  spendTokenInfo: spendTokenInfo,
  allowedSelectors: [ALLOW_SELECTORS],
  ethLimit: ETH_SPEND_LIMIT
} as const;
```
<br></br>
* Call Data (If Sponsored use with `userOperation`) 
```ts
const callData = encodeFunctionData({
  abi: accountABI,
  functionName: 'registerSessionKey',
  args: [
    key,
    keyReg
  ]
});

// This registration requires WebAuthn approval
const userOperation = await walletClient.prepareUserOperation({
  callData,
  signature: webAuthnStubSignature,
});

// Sign with WebAuthn (one-time approval for session key)
const webauthnData = await WebAuthnP256.sign({
  challenge: getUserOperationHash(userOperation),
  credentialId,
  rpId: window.location.hostname,
  userVerification: "required",
});
```
---
<br></br> 
---
<kbd style="padding: 2px 6px; font-size: 18px; background-color: #fc3c2f; border: 1px solid #ccc; border-radius: 4px;">4</kbd>&nbsp;&nbsp;&nbsp;&nbsp;*Executing Transactions with WebAuthn.*
Let's show the time when we mint some ERC-20 tokens. First, a UserOperation is prepared by us with a placeholder for its signature. Then, the actual WebAuthn signature acts in its place:
* `Preparing the Transaction`
```ts
// Encode the mint function call
const data = encodeFunctionData({
  abi: erc20ABI,
  functionName: "mint",
  args: [
    walletClient.account.address,
    parseEther("10"),  // Mint 10 tokens
  ],
});

// Prepare UserOperation with stub signature
const userOperation = await walletClient.prepareUserOperation({
  calls: [
    {
      to: erc20Address,
      data,
    },
  ],
  signature: webAuthnStubSignature,  // Placeholder signature
});
```

The actual signature is now generated using the WebAuthn credential:
```ts
// Get the UserOperation hash that needs to be signed
const userOperationHash = getUserOperationHash(userOperation);

// Sign with WebAuthn - this triggers biometric authentication
const webauthnData = await WebAuthnP256.sign({
  challenge: userOperationHash,
  credentialId,                      // The credential we created earlier
  rpId: window.location.hostname,    // Relying party identifier
  userVerification: "required",      // Require user verification
});

// Replace stub signature with the actual WebAuthn signature
userOperation.signature = encodeWebAuthnSignature(webauthnData);

// Send to bundler for execution
await bundlerClient.sendUserOperation(userOperation);
```
* The user experiences a familiar biometric prompt like Face ID, fingerprint, etc., so once they authenticate, someone signs then submits the transaction.