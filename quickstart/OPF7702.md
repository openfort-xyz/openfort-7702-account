# Openfort EIP-7702 Smart Accounts Quickstart

<p align="center">
  <img src="../docs/Logo_black_primary_no_bg.png" alt="Openfort" style="width: 300px;" />
</p>

> üöß **Work in Progress** ‚Äì contracts are unaudited and may change without notice.

Comprehensive smart accounts with **EIP-7702** authorities, **ERC-4337** validation, WebAuthn passkeys, and scoped session keys.

---

## Overview

Smart accounts should feel seamless from onboarding to day‚Äëto‚Äëday usage:

- **Zero deployment friction** ‚Äì enable a 7702 authority and immediately operate as a smart contract.
- **Passkey-first authentication** ‚Äì WebAuthn/WebCrypto credentials act as master keys.
- **Session keys with guardrails** ‚Äì limited lifetime, function selectors, token spend ceilings, and optional gas envelopes.
- **Guardian-backed recovery** ‚Äì use trusted parties to rotate master keys without redeploying storage.
- **AA compatibility** ‚Äì drop-in with ERC-4337 EntryPoint, bundlers, and sponsor flows.

üëâ Live demo: [https://7702.openfort.xyz](https://7702.openfort.xyz)

---

## What You'll Build

1. Prepare an EIP-7702 authorization (self or ephemeral) so an EOA can run the account code.
2. Initialize the account with a WebAuthn master key, optional session key, and initial guardian.
3. Register additional session keys (e.g. WebCrypto P256) with limited permissions.
4. Execute UserOperations with WebAuthn signatures.
5. Execute UserOperations with session keys (no biometric prompt).

---

## Prerequisites

```bash
npm install viem @noble/secp256k1 ox permissionless
# or
yarn add viem @noble/secp256k1 ox permissionless
```

You‚Äôll also need a bundler / EntryPoint RPC (e.g. Stackup, Pimlico) and a WebAuthn-capable browser.

---

## 1. Prepare an EIP-7702 Authorization

An EOA can temporarily run smart account code through an EIP-7702 authorization. You may self-authorize or mint a short-lived ‚Äúephemeral EOA‚Äù.

### Self-authorization

```ts
import { createWalletClient, http } from "viem";
import { privateKeyToAccount } from "viem/accounts";
import { sepolia } from "viem/chains";

const SEPOLIA_RPC = "<rpc>";
const authorizer = privateKeyToAccount("0x‚Ä¶");

const walletClient = createWalletClient({
  account: authorizer,
  chain: sepolia,
  transport: http(SEPOLIA_RPC),
});

const authorization = await walletClient.prepareAuthorization({
  account: authorizer,
  contractAddress: "0x0000000084b697f51642a784305c682dee8a8fc3",
  executor: "self",
});
```

### Ephemeral EOA

```ts
import { createClient, http } from "viem";
import { sepolia } from "viem/chains";
import { prepareAuthorization } from "viem/actions";
import { generatePrivateKey, privateKeyToAccount } from "viem/accounts";

const privateKey = generatePrivateKey();
const signer = privateKeyToAccount(privateKey);

const client = createClient({
  chain: sepolia,
  transport: http("<rpc>"),
});

const authorization = await prepareAuthorization(client, {
  account: signer.address,
  contractAddress: "0x0000000084b697f51642a784305c682dee8a8fc3",
});
```

---

## 2. Initialize the Account (WebAuthn Master + Optional Session Key + Guardian)

`OPF7702Recoverable.initialize` wires the master key, optional session key, and first guardian. The call must originate from the EntryPoint or a self-call via EIP-7702 authorization.

```solidity
function initialize(
    IKey.KeyDataReg calldata _keyData,
    IKey.KeyDataReg calldata _sessionKeyData,
    bytes memory _signature,
    bytes32 _initialGuardian
) external initializer;
```

### Create a WebAuthn Passkey

```ts
import { Bytes, WebAuthnP256 } from "ox";
import { toHex } from "viem";

const credential = await WebAuthnP256.createCredential({
  authenticatorSelection: {
    requireResidentKey: false,
    residentKey: "preferred",
    userVerification: "required",
  },
  user: {
    id: Bytes.from(account.address),
    name: `${account.address.slice(0, 6)}‚Ä¶${account.address.slice(-4)}`,
  },
});

const credentialId = credential.id;
const pubX = toHex(credential.publicKey.x, { size: 32 });
const pubY = toHex(credential.publicKey.y, { size: 32 });
```

### Build Master Key Registration Payload

Master keys must satisfy `_masterKeyValidation`: `limits == 0`, `validAfter == 0`, `validUntil == type(uint48).max`, `KeyControl.Self`, and key type not P256/P256NONKEY.

```ts
import {
  encodeAbiParameters,
  encodeFunctionData,
  keccak256,
  toHex,
  zeroAddress,
} from "viem";

enum KeyType {
  EOA,
  WEBAUTHN,
  P256,
  P256_NON_KEY,
}

enum KeyControl {
  Self,
  Custodial,
}

const masterKeyBytes = encodeAbiParameters(
  [{ type: "bytes32" }, { type: "bytes32" }],
  [pubX, pubY]
);

const masterKeyReg = {
  keyType: KeyType.WEBAUTHN,
  validUntil: Number.MAX_SAFE_INTEGER, // type(uint48).max (281474976710655)
  validAfter: 0,
  limits: 0,
  key: masterKeyBytes,
  keyControl: KeyControl.Self,
} as const;

const initialGuardian = keccak256("guardian-address");
```

### Optional: Pre-register a Session Key

Session keys must have `limits > 0`. If you plan to add permissions later, you can supply an empty payload (`{ key: "0x" }`) during initialization and register session keys afterward instead.

```ts
const now = Math.floor(Date.now() / 1000);

const sessionKeyBytes = encodeAbiParameters(
  [{ type: "bytes32" }, { type: "bytes32" }],
  [pubX, pubY]
);

const sessionKeyReg = {
  keyType: KeyType.P256_NON_KEY,
  validUntil: now + 7 * 24 * 3600,
  validAfter: now,
  limits: 5, // allow 5 calls before refresh
  key: sessionKeyBytes,
  keyControl: KeyControl.Self,
} as const;
```

### Encode Initialization Call

`SIGNATURE_EIP712` is produced by signing `OPF7702Recoverable.getDigestToInit(masterKeyReg, sessionKeyReg, initialGuardian)` with the WebAuthn credential.

```ts
const callData = encodeFunctionData({
  abi: accountABI,
  functionName: "initialize",
  args: [
    masterKeyReg,
    sessionKeyReg, // or an empty struct if no session key
    SIGNATURE_EIP712,
    initialGuardian,
  ],
});

const userOperation = await walletClient.prepareUserOperation({
  callData,
  authorization: signedAuthorization, // from Step 1
});
```

Submit the UserOperation to your bundler. Once included, the account runs entirely on-chain with WebAuthn as the master key.

---

## 3. Register Additional Session Keys

`KeysManager.registerKey` adds new session keys post-initialization. Custodial keys (`KeyControl.Custodial`) automatically initialise a session gas budget.

```solidity
function registerKey(IKey.KeyDataReg calldata _keyData) external;
```

Example: create a WebCrypto P256 key pair for session use.

```ts
import { WebCryptoP256 } from "ox";

const keyPair = await WebCryptoP256.createKeyPair();
const publicKey = await WebCryptoP256.getPublicKey({ publicKey: keyPair.publicKey });

const sessionKeyBytes = encodeAbiParameters(
  [{ type: "bytes32" }, { type: "bytes32" }],
  [
    toHex(publicKey.x, { size: 32 }),
    toHex(publicKey.y, { size: 32 }),
  ]
);

const sessionKeyReg = {
  keyType: KeyType.P256_NON_KEY,
  validUntil: now + 3600,
  validAfter: now,
  limits: 3,
  key: sessionKeyBytes,
  keyControl: KeyControl.Custodial, // auto-init GasPolicy
} as const;

const callData = encodeFunctionData({
  abi: accountABI,
  functionName: "registerKey",
  args: [sessionKeyReg],
});

const userOperation = await walletClient.prepareUserOperation({
  callData,
  signature: SIGNED_MASTER_KEY_USEROP, // WebAuthn master key signs once
});
```

After the call succeeds, configure permissions:

```ts
// Example: allow session key to mint on a specific ERC-20 contract
await accountClient.setCanCall(sessionKeyId, erc20Address, erc20Abi.getFunction("mint").selector, true);

// Set an ERC-20 allowance of 100 tokens per day
await accountClient.setTokenSpend(sessionKeyId, erc20Address, parseUnits("100", 18), SpendPeriod.Day);
```

---

## 4. Execute Transactions with WebAuthn

Master-key operations require a WebAuthn prompt. Prepare the UserOperation, stub the signature, then replace it with a WebAuthn assertion.

```ts
const data = encodeFunctionData({
  abi: erc20ABI,
  functionName: "mint",
  args: [walletClient.account.address, parseEther("10")],
});

const userOperation = await walletClient.prepareUserOperation({
  calls: [{ to: erc20Address, data }],
  signature: webAuthnStubSignature,
});

const userOperationHash = getUserOperationHash(userOperation);

const webauthnData = await WebAuthnP256.sign({
  challenge: userOperationHash,
  credentialId,
  rpId: window.location.hostname,
  userVerification: "required",
});

userOperation.signature = encodeWebAuthnSignature(webauthnData);

await bundlerClient.sendUserOperation(userOperation);
```

---

## 5. Execute Transactions with Session Keys

Once a session key is registered and permissions are configured, it can sign UserOperations without prompting the user.

```ts
const userOperation = await walletClient.prepareUserOperation({
  calls: [
    {
      to: erc20Address,
      data: encodeFunctionData({
        abi: erc20ABI,
        functionName: "mint",
        args: [walletClient.account.address, parseEther("5")],
      }),
    },
  ],
  signature: sessionStubSignature,
});

const hash = getUserOperationHash(userOperation);
const { r, s } = await WebCryptoP256.sign({
  privateKey: keyPair.privateKey,
  payload: hash,
});

userOperation.signature = encodeP256Signature({ r, s });

await bundlerClient.sendUserOperation(userOperation);
```

If the session key were custodial, the GasPolicy would automatically debit the gas envelope during validation.

---

## Next Steps

- Configure guardian proposals via `SocialRecoveryManager` to add/remove recovery parties.
- Use `setCanCall`, `updateTokenSpend`, `pauseKey`, and `revokeKey` to manage session key lifecycles.
- Integrate Paymaster flows by supplying `paymasterAndData` and letting GasPolicy account for sponsored ops.

By combining WebAuthn for high-assurance actions and session keys for everyday use, you can deliver a secure yet frictionless experience powered by EIP-7702 + ERC-4337.
